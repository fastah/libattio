/*
Attio API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
Contact: support@attio.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package libattio

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MeetingsAPIService MeetingsAPI service
type MeetingsAPIService service

type ApiV2MeetingsGetRequest struct {
	ctx context.Context
	ApiService *MeetingsAPIService
	limit *int32
	cursor *string
	linkedObject *string
	linkedRecordId *string
	participants *string
	sort *string
	endsFrom *string
	startsBefore *string
	timezone *string
}

func (r ApiV2MeetingsGetRequest) Limit(limit int32) ApiV2MeetingsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2MeetingsGetRequest) Cursor(cursor string) ApiV2MeetingsGetRequest {
	r.cursor = &cursor
	return r
}

func (r ApiV2MeetingsGetRequest) LinkedObject(linkedObject string) ApiV2MeetingsGetRequest {
	r.linkedObject = &linkedObject
	return r
}

func (r ApiV2MeetingsGetRequest) LinkedRecordId(linkedRecordId string) ApiV2MeetingsGetRequest {
	r.linkedRecordId = &linkedRecordId
	return r
}

func (r ApiV2MeetingsGetRequest) Participants(participants string) ApiV2MeetingsGetRequest {
	r.participants = &participants
	return r
}

func (r ApiV2MeetingsGetRequest) Sort(sort string) ApiV2MeetingsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV2MeetingsGetRequest) EndsFrom(endsFrom string) ApiV2MeetingsGetRequest {
	r.endsFrom = &endsFrom
	return r
}

func (r ApiV2MeetingsGetRequest) StartsBefore(startsBefore string) ApiV2MeetingsGetRequest {
	r.startsBefore = &startsBefore
	return r
}

func (r ApiV2MeetingsGetRequest) Timezone(timezone string) ApiV2MeetingsGetRequest {
	r.timezone = &timezone
	return r
}

func (r ApiV2MeetingsGetRequest) Execute() (*V2MeetingsGet200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsGetExecute(r)
}

/*
V2MeetingsGet List meetings

Lists all meetings in the workspace using a deterministic sort order.

Required scopes: `meeting:read`, `record_permission:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2MeetingsGetRequest
*/
func (a *MeetingsAPIService) V2MeetingsGet(ctx context.Context) ApiV2MeetingsGetRequest {
	return ApiV2MeetingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V2MeetingsGet200Response
func (a *MeetingsAPIService) V2MeetingsGetExecute(r ApiV2MeetingsGetRequest) (*V2MeetingsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MeetingsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeetingsAPIService.V2MeetingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.linkedObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linked_object", r.linkedObject, "form", "")
	}
	if r.linkedRecordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linked_record_id", r.linkedRecordId, "form", "")
	}
	if r.participants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "participants", r.participants, "form", "")
	} else {
		var defaultValue string = ""
		r.participants = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "start_asc"
		r.sort = &defaultValue
	}
	if r.endsFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ends_from", r.endsFrom, "form", "")
	}
	if r.startsBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "starts_before", r.startsBefore, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
		var defaultValue string = "UTC"
		r.timezone = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MeetingsMeetingIdGetRequest struct {
	ctx context.Context
	ApiService *MeetingsAPIService
	meetingId string
}

func (r ApiV2MeetingsMeetingIdGetRequest) Execute() (*V2MeetingsMeetingIdGet200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsMeetingIdGetExecute(r)
}

/*
V2MeetingsMeetingIdGet Get a meeting

Get a single meeting by ID.

Required scopes: `meeting:read`, `record_permission:read`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param meetingId
 @return ApiV2MeetingsMeetingIdGetRequest
*/
func (a *MeetingsAPIService) V2MeetingsMeetingIdGet(ctx context.Context, meetingId string) ApiV2MeetingsMeetingIdGetRequest {
	return ApiV2MeetingsMeetingIdGetRequest{
		ApiService: a,
		ctx: ctx,
		meetingId: meetingId,
	}
}

// Execute executes the request
//  @return V2MeetingsMeetingIdGet200Response
func (a *MeetingsAPIService) V2MeetingsMeetingIdGetExecute(r ApiV2MeetingsMeetingIdGetRequest) (*V2MeetingsMeetingIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V2MeetingsMeetingIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeetingsAPIService.V2MeetingsMeetingIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings/{meeting_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_id"+"}", url.PathEscape(parameterValueToString(r.meetingId, "meetingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2MeetingsMeetingIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
